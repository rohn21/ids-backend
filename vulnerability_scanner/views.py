from django.shortcuts import render
from rest_framework.response import Response
from rest_framework import views, status, viewsets
import requests, logging
from rest_framework_simplejwt.authentication import JWTAuthentication
from .serializers import VulnerabilitySerializer, ScanSerializer
from rest_framework.permissions import IsAuthenticated
from .models import Scan, Vulnerability
from utils.scanner.check_security_misconfigurations import check_security_misconfigurations
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MisconfigurationScanner:

    def __init__(self, target_url):
        self.target_url = target_url
        self.headers = None
        self.security_issues = []

    def scan_headers(self):
        """Scan HTTP headers for common security misconfigurations."""
        try:
            response = requests.get(self.target_url)
            self.headers = response.headers

            # Check for X-Content-Type-Options
            if "X-Content-Type-Options" not in self.headers:
                self.security_issues.append("Missing X-Content-Type-Options header")

            # Check for Strict-Transport-Security
            if "Strict-Transport-Security" not in self.headers:
                self.security_issues.append("Missing Strict-Transport-Security header")

            # Check for X-Frame-Options
            if "X-Frame-Options" not in self.headers:
                self.security_issues.append("Missing X-Frame-Options header")

            # Check for Content-Security-Policy
            if "Content-Security-Policy" not in self.headers:
                self.security_issues.append("Missing Content-Security-Policy header")

        except requests.RequestException as e:
            self.security_issues.append(f"Error checking headers: {str(e)}")

    def scan_https(self):
        """Check if the target URL uses HTTPS."""
        if not self.target_url.startswith("https://"):
            self.security_issues.append("Target is not using HTTPS.")

    def scan(self):
        """Run all scans and return the results."""
        self.scan_headers()
        self.scan_https()
        return self.security_issues


def scan_url(url):
    try:
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            # Basic check for a potential vulnerability
            if "X-Frame-Options" not in response.headers:
                return f"Missing X-Frame-Options header"
            else:
                return "No vulnerabilities found"
        else:
            return f"Failed to retrieve page. Status code: {response.status_code}"
    except Exception as e:
        return str(e)


class ScanVulnerabilityView(views.APIView):
    def post(self, request):
        serializer = ScanSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class ScanViewSet(viewsets.ModelViewSet):
    queryset = Scan.objects.all()
    serializer_class = ScanSerializer
    authentication_classes = [JWTAuthentication]
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        target_url = request.data.get("target_url")
        scan_type = request.data.get("scan_type", "WEB")

        if not target_url:
            return Response({"error": "target_url is required"}, status=status.HTTP_400_BAD_REQUEST)

        scan = Scan.objects.create(
            target_url=target_url,
            scan_type=scan_type,
            scan_status="RUNNING",
            scan_user=request.user,
            scan_start_time=datetime.now()
        )

        findings = check_security_misconfigurations(target_url)
        # task = run_nikto_scan.delay(target_url)

        for finding in findings:
            if "error" in finding:
                logger.error(f"Error during scan: {finding['error']}")
            else:
                Vulnerability.objects.create(scan=scan, **finding)

        # Update scan status
        scan.scan_status = "COMPLETED"
        scan.scan_end_time = datetime.now()
        scan.save()

        return Response({
            "detail": "Scan completed successfully!",
            "scan_id": scan.id,
            "target_url": target_url,
            "findings": findings,
            # "task":task
        }, status=status.HTTP_201_CREATED)
